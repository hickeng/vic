#!/bin/bash

set -x

echo 1 > /proc/sys/net/ipv4/conf/all/arp_notify
echo 1 > /proc/sys/net/ipv4/conf/default/arp_notify

# depending on kernel, some may already be loaded or built in
echo "Loading drivers"
drivers=( \
    "vmw_pvscsi" \
    "vmxnet3" \
	"nfnetlink" \
	"iptable_filter" \
	"xt_conntrack" \
    "nf_nat_redirect" \
    "xt_REDIRECT" \
    "nf_nat_ipv4" \
    "iptable_nat" \
	"nf_conntrack" \
	"nf_conntrack_ipv4" \
	"nf_defrag_ipv4" \
	"ipt_REJECT"\
	"nf_reject_ipv4"\
	"nfsv3" \
)

for i in ${drivers[@]}; do
    modprobe $i
done

# allow udev (whether systemd-udevd or raw udevd) to handle newly available devices
udevadm trigger
udevadm settle


MOUNTPOINT="/mnt/containerfs"
mkdir -p /mnt/containerfs

echo "Waiting for rootfs"
while [ ! -e /dev/disk/by-label/containerfs ]; do sleep 0.1;done
if mount -t ext4 /dev/disk/by-label/containerfs ${MOUNTPOINT}; then
    # ensure mountpoint exists
    mkdir -p ${MOUNTPOINT}/.tether

    # ensure that no matter what we have access to required devices
    # WARNING WARNING WARNING WARNING WARNING
    # if the tmpfs is not large enough odd hangs can occur and the ESX event log will
    # report the guest disabling the CPU
    mount -t tmpfs -o size=356m tmpfs ${MOUNTPOINT}/.tether/

    # enable full system functionality in the container
    ln -s lib64 ${MOUNTPOINT}/.tether/lib
    mkdir -p ${MOUNTPOINT}/.tether/{lib64,usr/lib/iptables,run}

    echo "Publishing modules within container"
    mkdir -p ${MOUNTPOINT}/lib/modules
    mkdir -p ${MOUNTPOINT}/.tether/lib/modules
    mount --bind ${MOUNTPOINT}/.tether/lib/modules ${MOUNTPOINT}/lib/modules
    cp -pr /lib/modules/* ${MOUNTPOINT}/lib/modules/

    # switch to the new root
    echo "prepping for switch to container filesystem"

    cp /bin/tether ${MOUNTPOINT}/.tether/tether
    ln -s tether ${MOUNTPOINT}/.tether/tether-debug

    echo 'tether tmpfs size before copying libraries: '
    df -k ${MOUNTPOINT}/.tether

    install-iptables ${MOUNTPOINT}/.tether
    install-entropy ${MOUNTPOINT}/.tether

    echo 'tether tmpfs size after copying libraries: '
    df -k ${MOUNTPOINT}/.tether

    # Create VIC chain
    iptables -N VIC
    # Set the default policy on all chains to drop traffic
#    iptables -P INPUT DROP
#    iptables -P OUTPUT DROP
#    iptables -P FORWARD DROP
    iptables -P INPUT ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -P FORWARD ACCEPT
    # Direct any incoming/outgoing traffic immediately to VIC chain
    iptables -A INPUT -j VIC
    iptables -A OUTPUT -j VIC
    # Always allow traffic on loopback interface
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A OUTPUT -o lo -j ACCEPT
    iptables -A FORWARD -i lo -o lo -j ACCEPT

    until [[ $(ls -1 /dev/disk/by-label | wc -l) -eq $(ls -1 /sys/block | grep -v ram | grep -v loop | wc -l) ]]; do sleep 0.1;done

    echo "switching to the new mount"
    if which systemctl > /dev/null; then
        systemctl switch-root ${MOUNTPOINT} /.tether/tether 2>&1
    else
        exec switch_root ${MOUNTPOINT} /.tether/tether 2>&1 
        # if successful then nothing after this point executes
        echo "Failed to switch to the new mount"
    fi
else
    # TODO: what do we do here? we really need to somehow report an error
    # fail hard
    echo "Unable to chroot into container filesystem"
fi

# Shut the system down
if which systemctl; then
    systemctl poweroff
else
    halt
fi